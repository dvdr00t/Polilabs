#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <dirent.h>
#include <pthread.h>

#define MAX_PATH_NAME 100
#define MAX_FILE_NAME 40
#define MAX_LINE_LENGTH 200
#define ONLY_WRITE "w"
#define ONLY_READ "r"

/*
*   + --------- +
*   | FUNCTIONS |
*   + --------- +
*/

/**
 * @brief Runs N threads. Each thread visits a source directory recursively and print stats in the stdout.
 * 
 * @param source_directories 
 * @param N 
 * @return 0 on success.  
 */
int visit_directories(char *source_directories[], int N);

/**
 * @brief Thread routine function
 * 
 * @param data 
 * @return (void *) EXIT_SUCCESS on success.
 */
void *routine(void *data);

/**
 * @brief Visits a source directory recursively and print stats in the specific file generated by the theread.
 * 
 * @param path 
 * @param fp_out 
 * @return int 
 */
int visit_recursively(char *path, FILE *fp_out);

/**
 * @brief Merge results from file and print them to stdout
 * 
 * @return int 
 */
int show_result(void);

/**
 * @brief Check if the name passed a string matches "*_thread.txt"
 * 
 * @param src_name 
 * @return 1 on success.
 */
int check_name(char *src_name);

/**
 * @brief Main driver code.
 * 
 * @param args 
 * @param argv 
 * @return int 
 */
int main (int args, char *argv[]) {

    /* CHECKING USER INPUT */
    if (args <= 1) {
        fprintf(stderr, "[USAGE] ./exe04 path_1 ... <path_x>");
        exit(EXIT_FAILURE);
    }

    /* PARSING USER INPUT */
    int N = args-1;
    struct stat buffer;
    char **source_directories = (char **) malloc(N * sizeof(char *));
    if (source_directories == NULL) {
        fprintf(stderr, "[ERROR] malloc() failed execution\n\n");
        exit(EXIT_FAILURE);
    }
    for (int i = 1, j = 0; i <= N; i++, j++) {

        /* CHECKING IF USER INPUT EXISTS AS A DIRECTORY */
        if (stat(argv[i], &buffer) != 0) {
            fprintf(stderr, "[ERROR] stat() function failed execution\n\n");
            exit(EXIT_FAILURE);
        }
        if (!S_ISDIR(buffer.st_mode)) {
            fprintf(stderr, "[ERROR] %s is not a path to an existing direectory...\n\n", argv[i]);
            exit(EXIT_FAILURE);
        }

        /* CREATING SPACE FOR STORING THE USER INPUT */ 
        source_directories[j] = (char *) malloc(MAX_PATH_NAME * sizeof(char));
        if (source_directories[j] == NULL) {
            fprintf(stderr, "[ERROR] malloc() failed execution\n\n");
            exit(EXIT_FAILURE);
        }
        sprintf(source_directories[j], "%s", argv[i]);
    }

    /* EXECUTING RECURSIVE VISIT WITH THREADS (VERSION A) */
    if (visit_directories(source_directories, N) != 0) {
        fprintf(stderr, "[ERROR] visit_directories() failed execution\n\n");
        exit(EXIT_FAILURE);
    }

    /* COPYING RESULT TO STDOUT */
    if (show_result() != 0) {
        fprintf(stderr, "[ERROR] show_result() failed execution\n");
        exit(EXIT_FAILURE);
    }

    /* FREEING MEMORY */
    free(*source_directories);
    exit(EXIT_SUCCESS);
}

int visit_directories(char *source_directories[], int N) {
    
    /* GENERATING THREADS */
    pthread_t *threads_ID = (pthread_t *) malloc(N * sizeof(pthread_t));
    if (threads_ID == NULL) {
        fprintf(stderr, "[ERROR] malloc() failed execution\n\n");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < N; i++) {
        if (pthread_create(&threads_ID[i], NULL, routine, (void *) source_directories[i]) != 0) {				
			fprintf(stderr, "[ERROR] pthread_create() failed execution.\n\n");
			exit(EXIT_FAILURE);
		}
    }

    /* JOINING THREADS */
	int exit_status;
	for (int i = 0; i < N; i++) {
		if (pthread_join(threads_ID[i], (void*) &exit_status) != 0) {
			fprintf(stderr, "[ERROR] pthread_create() failed execution.\n\n");
			exit(EXIT_FAILURE);
		}
	}

    /* FREEING SPACE */
    free(threads_ID);

    return 0;
}

void *routine(void *data) {

    /* CAST TO CORRECT TYPE */
    char *path = (char *) data;

    /* OPENING FILE AS OUTPUT DESTINATION */
    char filename[MAX_FILE_NAME];
    sprintf(filename, "%d_thread.txt", pthread_self());
    FILE *fp_out = fopen(filename, ONLY_WRITE);
    if (fp_out == NULL) {
        fprintf(stderr, "[ERROR] file %s failed to open\n", filename);
        return (void *) EXIT_FAILURE;
    }

    /* DISPLAYING SOURCE DIRECTORY INFORMATION */
    fprintf(fp_out, "> [THREAD ID: %u] directory: %s\n", pthread_self(), path);

    /* EXECUTING ROUTINE OF THE THREAD */
    if (visit_recursively(path, fp_out) != 0) {
        fprintf(stderr, "[ERROR] visit_recursive() failed execution\n\n");
        return (void *) EXIT_FAILURE;
    }

    /* CLOSING FILE */
    if (fclose(fp_out) != 0) {
        fprintf(stderr, "[ERROR] file %s failed to close\n", filename);
        return (void *) EXIT_FAILURE;
    }
    return (void *) EXIT_SUCCESS;
}

int visit_recursively(char *path, FILE *fp_out) {

    char *src_path_TMP;     //Path of the current element in working process in the directory

    /* OPENING SOURCE DIRECTORY AND CHECKING ERRORS */
    DIR *dp_src = opendir(path);
    if (dp_src == NULL) {
        fprintf(stderr, "[ERROR] opendir() function failed execution\n\n");
        return -1;
    }

    /* VISIT RECURSIVELY ALL THE TREE */
    struct dirent *dirp;
    struct stat buffer;
    while ((dirp = readdir(dp_src)) != NULL) {

        /*
        * ALLOCATING SPACE IN MEMORY FOR STORING TARGET PATH.
        * ---------------------------------------------------
        * Checking that the allocation has been successfully completed and then storing the argument 
        * passed by the user.
        */
        src_path_TMP = (char*) malloc((strlen(path) + strlen(dirp->d_name) + 1) * sizeof(char));
        if (src_path_TMP == NULL) {
            fprintf(stderr, "[ERROR] malloc() function failed execution\n\n");
            return -1;
        }
        sprintf(src_path_TMP, "%s/%s", path, dirp->d_name);

        /* CHECKING IF CURRENT VISITED NODE IS A FILE OR A DIRECTORY */
        if (lstat(src_path_TMP, &buffer) < 0) {
            fprintf(stderr, "[ERROR] Reading the content of %s failed during execution\n\n", src_path_TMP);
            return -1;
        }
        if (!S_ISDIR(buffer.st_mode)) {

            /* DISPLAYING FILE TO STDOUT */
            fprintf(fp_out, "> [THREAD ID: %u] filename: %s\n", pthread_self(), dirp->d_name);

        } else {
            if (strcmp(dirp->d_name, ".") != 0 && strcmp(dirp->d_name, "..") != 0) {

                /* DISPLAYING DIRECTORY TO STDOUT */
                fprintf(fp_out, "> [THREAD ID: %u] directory: %s\n", pthread_self(), dirp->d_name);

                /* VISIT RECURSIVELY */
                if (visit_recursively(src_path_TMP, fp_out) != 0) {
                    fprintf(stderr, "[ERROR] visit_recursive() failed execution\n\n");
                    return -1;
                }
            }
        }
        /* FREEING MEMORY */
        free(src_path_TMP);
    }

    /* CLOSING SOURCE DIRECTORY AND CHECKING ERRORS */
    if (closedir(dp_src) != 0) {
        fprintf(stderr, "[ERROR] closedir() function failed execution\n\n");
        return -1;
    }
    return 0;
}

int show_result(void) {

    /* MAIN THREAD OPENS CURRENT DIRECTORY TO READ FILES */
    DIR *dp_src = opendir(".");
    if (dp_src == NULL) {
        fprintf(stderr, "[ERROR] opendir() function failed execution\n\n");
        return -1;
    }

    /* READING CONTENT OF DIRECTORY AND SEARCH RELATED FILES */
    struct stat buffer;
    struct dirent *dirp;
    while ((dirp = readdir(dp_src)) != NULL) {

        /* CHECKING IF NAME CORRESPONDS TO THREAD FILE NAME */
        if (check_name(dirp->d_name)) {

            /* OPENING FILE */
            FILE *fp_in = fopen(dirp->d_name, ONLY_READ);
            if (fp_in == NULL) {
                fprintf(stderr, "[ERROR] file %s failed to open\n", dirp->d_name);
                return -1;
            }

            /* READING CONTENT OF FILE AND PRINTING TO STDOUT */
            char buffer[MAX_LINE_LENGTH];
            while (fgets(buffer, MAX_LINE_LENGTH, fp_in) != NULL) {
                if (strcmp(buffer, "\n") != 0) {
                    fprintf(stdout, "%s", buffer);
                }
            }

            /* CLOSING FILE */
            if (fclose(fp_in) != 0) {
                fprintf(stderr, "[ERROR] file %s failed to close\n", dirp->d_name);
                return -1;
            }
        }
    }
    return 0;
}

int check_name(char *src_name) {

    /* MANUALLY CHECKING FINAL CHARACTERS OF THE STRING */ 
    int name_length = strlen(src_name);
    char sliced_src_name[12];
    for (int i = name_length-11, j = 0; i < name_length; i++, j++) {
        sliced_src_name[j] = src_name[i];
    }
    if (strcmp(sliced_src_name, "_thread.txt") == 0) {
        return 1;
    }
    return 0;
}
